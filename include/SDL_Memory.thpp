/* SDL_Memory.thpp
 * Copyright Â© 2024 Saul D. Beniquez
 * License: Mozilla Public License v. 2.0
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v.2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at https://mozilla.org/MPL/2.0/.
 */
/*! \file SDL_Memory.thpp
 * \brief Custom smart pointers for SDL resources.
 *
 * This file defines two custom smart pointer classes, `unique_sdl_ptr` and
 * `shared_sdl_ptr`, tailored for managing SDL resources. These classes automate
 * resource destruction by calling the appropriate SDL_Destroy*() functions in
 * their destructors. Additionally, they provide automatic conversion back into
 * a raw pointer for seamless integration with SDL functions.
 *
 * Usage example:
 * \code
 * #include "SDL_Memory.thpp"
 *
 * int main() {
 *     SDL_Window* sdlWindow = SDL_CreateWindow("SDL Window",
 *                                              SDL_WINDOWPOS_UNDEFINED,
 *                                              SDL_WINDOWPOS_UNDEFINED,
 *                                              800, 600, SDL_WINDOW_SHOWN);
 *     if (sdlWindow == nullptr) {
 *         // Handle error
 *         return 1;
 *     }
 *
 *     // Using unique_sdl_ptr with custom deleter
 *     elemental::unique_sdl_ptr<SDL_Window> windowPtr(sdlWindow);
 *
 *     // Now you can use windowPtr directly as SDL_Window*
 *     // unique_sdl_ptr is automatically converted to SDL_Window* where needed
 *     SDL_ShowWindow(windowPtr);
 *
 *     return 0;
 * }
 * \endcode
 *
 */
#pragma once

#include <SDL.h>
#include <memory>

namespace elemental {
/*! \brief A catch-call deleter functor.  Add a method overload for your
 * favorite SDL_* pointer type, to have the uniqe_sdl_ptr and shared_sdl_ptr
 * automatically manage resource SDL resources. */
struct SDL_ResourceDeleter
{
	inline void operator()(SDL_Window* window_ptr)
	{
		SDL_DestroyWindow(window_ptr);
	}
	inline void operator()(SDL_Renderer* renderer_ptr)
	{
		SDL_DestroyRenderer(renderer_ptr);
	}
	inline void operator()(SDL_Surface* surface_ptr)
	{
		SDL_FreeSurface(surface_ptr);
	}
	inline void operator()(SDL_Texture* texture_ptr)
	{
		SDL_DestroyTexture(texture_ptr);
	}
	inline void operator()(SDL_Joystick* joystick_ptr){
		SDL_JoystickClose(joystick_ptr);
	}
};

template<typename T, typename D = SDL_ResourceDeleter>
struct unique_sdl_ptr : public std::unique_ptr<T, D>
{
	using std::unique_ptr<T, D>::unique_ptr;
	operator T*() const { return this->get(); }

	// Assignment operator for raw pointer using std::move
	unique_sdl_ptr& operator=(T* ptr)
	{
		this->reset(ptr);
		return *this;
	}
};

template<typename T, typename D = SDL_ResourceDeleter>
struct shared_sdl_ptr : public std::shared_ptr<T>
{
	using std::shared_ptr<T>::shared_ptr;
	shared_sdl_ptr(T* ptr, D deleter = D{})
	    : std::shared_ptr<T>(ptr, deleter)
	{
	}
	operator T*() const { return this->get(); }

	// Assignment operator for raw pointer using std::move
	shared_sdl_ptr& operator=(T* ptr)
	{
		this->reset(ptr, D{});
		return *this;
	}
};
}

// clang-format off
// vim: set foldmethod=syntax textwidth=80 ts=8 sts=0 sw=8 foldlevel=99 noexpandtab ft=cpp.doxygen :
